/*
 * hm2057.c - hm2057 sensor driver
 * Based on "ov2710.c"
 *
 * Copyright (c) 2013, Yaroslav Levandovskiy <leyarx@gmail.com>
 *
 * 2013.11.29 	Registers config taken from hm2057 sensor driver for RockChip
 *				and partly Reverse Engineered from zImage for Wexler Tab 7t
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2. This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/debugfs.h>
#include <media/hm2057.h>

#define HM2057_TABLE_WAIT_MS 	0xFFFE
#define HM2057_TABLE_END 		0xFFFF
#define HM2057_MAX_RETRIES 		3

struct hm2057_reg {
	u16 addr;
	u8 val;
};

struct hm2057_info {
	int mode;
	struct i2c_client *i2c_client;
	struct hm2057_platform_data *pdata;
	bool sensor_opened;
};

static struct hm2057_info *info;

extern int tegra_camera_mclk_on_off(int on);

static struct hm2057_reg hm2057_init_data[] = {
	{0x0022,0x00},
	{0x0004,0x10},
	{0x0006,0x03},
	{0x000D,0x11},
	{0x000E,0x11},
	{0x000F,0x00},
	{0x0011,0x02},
	{0x0012,0x1C},
	{0x0013,0x01},
	{0x0015,0x02},
	{0x0016,0x80},
	{0x0018,0x00},
	{0x001D,0x40},
	{0x0020,0x00},

	{0x0023,0xFF},
	{0x008F,0x66},
	{0x0025,0x80},

	{0x0026,0x87},
	{0x0027,0x30},
	{0x0040,0x20},
	{0x0053,0x0A},
	{0x0044,0x06},
	{0x0046,0xD8},
	{0x004A,0x0A},
	{0x004B,0x72},
	{0x0075,0x01},
	{0x002A,0x1F},
	{0x0070,0x5F},
	{0x0071,0xFF},
	{0x0072,0x55},
	{0x0073,0x50},
	{0x0080,0xC8},
	{0x0082,0xA2},
	{0x0083,0xF0},
	{0x0085,0x11},
	{0x0086,0x02},
	{0x0087,0x80},
	{0x0088,0x6C},
	{0x0089,0x2E},
	{0x008A,0x7D},
	{0x008D,0x20},
	{0x0090,0x00},
	{0x0091,0x10},
	{0x0092,0x11},
	{0x0093,0x12},
	{0x0094,0x16},
	{0x0095,0x08},
	{0x0096,0x00},
	{0x0097,0x10},
	{0x0098,0x11},
	{0x0099,0x12},
	{0x009A,0x06},
	{0x009B,0x34},
	{0x00A0,0x00},
	{0x00A1,0x04},
	{0x011F,0xF7},
	{0x0120,0x36},
	{0x0121,0x83},
	{0x0122,0x7B},
	{0x0123,0xC2},
	{0x0124,0xDE},
	{0x0125,0xFF},
	{0x0126,0x70},
	{0x0128,0x1F},
	{0x0132,0x10},
	{0x0131,0xBD},
	{0x0140,0x14},
	{0x0141,0x0A},
	{0x0142,0x14},
	{0x0143,0x0A},
	{0x0144,0x04},
	{0x0145,0x00},
	{0x0146,0x20},
	{0x0147,0x0A},
	{0x0148,0x10},
	{0x0149,0x0C},
	{0x014A,0x80},
	{0x014B,0x80},
	{0x014C,0x2E},
	{0x014D,0x2E},
	{0x014E,0x05},
	{0x014F,0x05},
	{0x0150,0x0D},
	{0x0155,0x00},
	{0x0156,0x10},
	{0x0157,0x0A},
	{0x0158,0x0A},
	{0x0159,0x0A},
	{0x015A,0x05},
	{0x015B,0x05},
	{0x015C,0x05},
	{0x015D,0x05},
	{0x015E,0x08},
	{0x015F,0xFF},
	{0x0160,0x50},
	{0x0161,0x20},
	{0x0162,0x14},
	{0x0163,0x0A},
	{0x0164,0x10},
	{0x0165,0x0A},
	{0x0166,0x0A},
	{0x018C,0x24},
	{0x018D,0x04},
	{0x018E,0x00},
	{0x018F,0x11},
	{0x0190,0x80},
	{0x0191,0x47},
	{0x0192,0x48},
	{0x0193,0x64},
	{0x0194,0x32},
	{0x0195,0xc8},
	{0x0196,0x96},
	{0x0197,0x64},
	{0x0198,0x32},
	{0x0199,0x14},
	{0x019A,0x20},
	{0x019B,0x14},
	{0x01B0,0x55},
	{0x01B1,0x0C},
	{0x01B2,0x0A},
	{0x01B3,0x10},
	{0x01B4,0x0E},
	{0x01BA,0x10},
	{0x01BB,0x04},
	{0x01D8,0x40},
	{0x01DE,0x60},
	{0x01E4,0x10},
	{0x01E5,0x10},
	{0x01F2,0x0C},
	{0x01F3,0x14},
	{0x01F8,0x04},
	{0x01F9,0x0C},
	{0x01FE,0x02},
	{0x01FF,0x04},
	{0x0220,0x00},
	{0x0221,0xB0},
	{0x0222,0x00},
	{0x0223,0x80},
	{0x0224,0x8E},
	{0x0225,0x00},
	{0x0226,0x88},
	{0x022A,0x88},
	{0x022B,0x00},
	{0x022C,0x8C},
	{0x022D,0x13},
	{0x022E,0x0B},
	{0x022F,0x13},
	{0x0230,0x0B},
	{0x0233,0x13},
	{0x0234,0x0B},
	{0x0235,0x28},
	{0x0236,0x03},
	{0x0237,0x28},
	{0x0238,0x03},
	{0x023B,0x28},
	{0x023C,0x03},
	{0x023D,0x5C},
	{0x023E,0x02},
	{0x023F,0x5C},
	{0x0240,0x02},
	{0x0243,0x5C},
	{0x0244,0x02},
	{0x0251,0x0E},
	{0x0252,0x00},
	{0x0280,0x0A},
	{0x0282,0x14},
	{0x0284,0x2A},
	{0x0286,0x50},
	{0x0288,0x60},
	{0x028A,0x6D},
	{0x028C,0x79},
	{0x028E,0x82},
	{0x0290,0x8A},
	{0x0292,0x91},
	{0x0294,0x9C},
	{0x0296,0xA7},
	{0x0298,0xBA},
	{0x029A,0xCD},
	{0x029C,0xE0},
	{0x029E,0x2D},
	{0x02A0,0x06},
	{0x02E0,0x04},
	{0x02C0,0x8F},
	{0x02C1,0x01},
	{0x02C2,0x8F},
	{0x02C3,0x07},
	{0x02C4,0xE3},
	{0x02C5,0x07},
	{0x02C6,0xC1},
	{0x02C7,0x07},
	{0x02C8,0x70},
	{0x02C9,0x01},
	{0x02CA,0xD0},
	{0x02CB,0x07},
	{0x02CC,0xF7},
	{0x02CD,0x07},
	{0x02CE,0x5A},
	{0x02CF,0x07},
	{0x02D0,0xB0},
	{0x02D1,0x01},
	{0x0302,0x00},
	{0x0303,0x00},
	{0x0304,0x00},
	{0x02F0,0x80},
	{0x02F1,0x07},
	{0x02F2,0x8E},
	{0x02F3,0x00},
	{0x02F4,0xF2},
	{0x02F5,0x07},
	{0x02F6,0xCC},
	{0x02F7,0x07},
	{0x02F8,0x16},
	{0x02F9,0x00},
	{0x02FA,0x1E},
	{0x02FB,0x00},
	{0x02FC,0x9D},
	{0x02FD,0x07},
	{0x02FE,0xA6},
	{0x02FF,0x07},
	{0x0300,0xBD},
	{0x0301,0x00},
	{0x0305,0x00},
	{0x0306,0x00},
	{0x0307,0x00},
	{0x032D,0x00},
	{0x032E,0x01},
	{0x032F,0x00},
	{0x0330,0x01},
	{0x0331,0x00},
	{0x0332,0x01},
	{0x0333,0x82},
	{0x0334,0x00},
	{0x0335,0x84},
	{0x0336,0x00},
	{0x0337,0x01},
	{0x0338,0x00},
	{0x0339,0x01},
	{0x033A,0x00},
	{0x033B,0x01},
	{0x033E,0x04},
	{0x033F,0x86},
	{0x0340,0x30},
	{0x0341,0x44},
	{0x0342,0x4A},
	{0x0343,0x42},
	{0x0344,0x74},
	{0x0345,0x4F},
	{0x0346,0x67},
	{0x0347,0x5C},
	{0x0348,0x59},
	{0x0349,0x67},
	{0x034A,0x4D},
	{0x034B,0x6E},
	{0x034C,0x44},
	{0x0350,0x80},
	{0x0351,0x80},
	{0x0352,0x18},
	{0x0353,0x18},
	{0x0354,0x6E},
	{0x0355,0x4A},
	{0x0356,0x86},
	{0x0357,0xCA},
	{0x0358,0x06},
	{0x035A,0x06},
	{0x035B,0xA0},
	{0x035C,0x73},
	{0x035D,0x50},
	{0x035E,0xC0},
	{0x035F,0xA0},
	{0x0360,0x02},
	{0x0361,0x18},
	{0x0362,0x80},
	{0x0363,0x6C},
	{0x0364,0x00},
	{0x0365,0xF0},
	{0x0366,0x20},
	{0x0367,0x0C},
	{0x0369,0x00},
	{0x036A,0x10},
	{0x036B,0x10},
	{0x036E,0x20},
	{0x036F,0x00},
	{0x0370,0x10},
	{0x0371,0x18},
	{0x0372,0x0C},
	{0x0373,0x38},
	{0x0374,0x3A},
	{0x0375,0x13},
	{0x0376,0x22},
	{0x0380,0xFF},
	{0x0381,0x5A},
	{0x0382,0x46},
	{0x038A,0x40},
	{0x038B,0x08},
	{0x038C,0xC1},
	{0x038E,0x50},

	{0x038F,0x03},
	{0x0390,0x07},

	{0x0391,0x05},
	{0x0393,0x80},
	{0x0395,0x21},
	{0x0398,0x02},
	{0x0399,0x84},
	{0x039A,0x03},
	{0x039B,0x25},
	{0x039C,0x03},
	{0x039D,0xC6},
	{0x039E,0x05},
	{0x039F,0x08},
	{0x03A0,0x06},
	{0x03A1,0x4A},
	{0x03A2,0x07},
	{0x03A3,0x8C},
	{0x03A4,0x0A},
	{0x03A5,0x10},
	{0x03A6,0x0C},
	{0x03A7,0x0E},
	{0x03A8,0x10},
	{0x03A9,0x18},
	{0x03AA,0x20},
	{0x03AB,0x28},
	{0x03AC,0x1E},
	{0x03AD,0x1A},
	{0x03AE,0x13},
	{0x03AF,0x0C},
	{0x03B0,0x0B},
	{0x03B1,0x09},
	{0x03B3,0x10},
	{0x03B4,0x00},
	{0x03B5,0x10},
	{0x03B6,0x00},
	{0x03B7,0xEA},
	{0x03B8,0x00},
	{0x03B9,0x3A},
	{0x03BA,0x01},
	{0x03BB,0x9F},
	{0x03BC,0xCF},
	{0x03BD,0xE7},
	{0x03BE,0xF3},
	{0x03BF,0x01},
	{0x03D0,0xF8},
	{0x03E0,0x44},
	{0x03E1,0x41},
	{0x03E2,0x04},
	{0x03E4,0x24},
	{0x03E5,0x23},
	{0x03E6,0x04},
	{0x03E8,0x24},
	{0x03E9,0x23},
	{0x03EA,0x04},
	{0x03EC,0x24},
	{0x03ED,0x23},
	{0x03EE,0x04},
	{0x03F0,0x34},
	{0x03F1,0x33},
	{0x03F2,0x04},
	{0x0420,0x84},
	{0x0421,0x00},
	{0x0422,0x00},
	{0x0423,0x83},
	{0x0430,0x08},
	{0x0431,0x28},
	{0x0432,0x10},
	{0x0433,0x08},
	{0x0435,0x0C},
	{0x0450,0xFF},
	{0x0451,0xE8},
	{0x0452,0xC4},
	{0x0453,0x88},
	{0x0454,0x00},
	{0x0458,0x70},
	{0x0459,0x03},
	{0x045A,0x00},
	{0x045B,0x30},
	{0x045C,0x00},
	{0x045D,0x70},
	{0x0466,0x14},
	{0x047A,0x00},
	{0x047B,0x00},
	{0x0480,0x5C},
	{0x0481,0x06},
	{0x0482,0x0C},
	{0x04B0,0x54},
	{0x04B6,0x30},
	{0x04B9,0x10},
	{0x04B3,0x10},
	{0x04B1,0x8E},
	{0x04B4,0x20},
	{0x0540,0x00},
	{0x0541,0x9D},
	{0x0542,0x00},
	{0x0543,0xBC},
	{0x0580,0x01},
	{0x0581,0x0F},
	{0x0582,0x04},
	{0x0594,0x00},
	{0x0595,0x04},
	{0x05A9,0x03},
	{0x05AA,0x40},
	{0x05AB,0x80},
	{0x05AC,0x0A},
	{0x05AD,0x10},
	{0x05AE,0x0C},
	{0x05AF,0x0C},
	{0x05B0,0x03},
	{0x05B1,0x03},
	{0x05B2,0x1C},
	{0x05B3,0x02},
	{0x05B4,0x00},
	{0x05B5,0x0C},
	{0x05B8,0x80},
	{0x05B9,0x32},
	{0x05BA,0x00},
	{0x05BB,0x80},
	{0x05BC,0x03},
	{0x05BD,0x00},
	{0x05BF,0x05},
	{0x05C0,0x10},
	{0x05C3,0x00},
	{0x05C4,0x0C},
	{0x05C5,0x20},
	{0x05C7,0x01},
	{0x05C8,0x14},
	{0x05C9,0x54},
	{0x05CA,0x14},
	{0x05CB,0xE0},
	{0x05CC,0x20},
	{0x05CD,0x00},
	{0x05CE,0x08},
	{0x05CF,0x60},
	{0x05D0,0x10},
	{0x05D1,0x05},
	{0x05D2,0x03},
	{0x05D4,0x00},
	{0x05D5,0x05},
	{0x05D6,0x05},
	{0x05D7,0x05},
	{0x05D8,0x08},
	{0x05DC,0x0C},
	{0x05D9,0x00},
	{0x05DB,0x00},
	{0x05DD,0x0F},
	{0x05DE,0x00},
	{0x05DF,0x0A},
	{0x05E0,0xA0},
	{0x05E1,0x00},
	{0x05E2,0xA0},
	{0x05E3,0x00},
	{0x05E4,0x04},
	{0x05E5,0x00},
	{0x05E6,0x83},
	{0x05E7,0x02},
	{0x05E8,0x06},
	{0x05E9,0x00},
	{0x05EA,0xE5},
	{0x05EB,0x01},
	{0x0660,0x04},
	{0x0661,0x16},
	{0x0662,0x04},
	{0x0663,0x28},
	{0x0664,0x04},
	{0x0665,0x18},
	{0x0666,0x04},
	{0x0667,0x21},
	{0x0668,0x04},
	{0x0669,0x0C},
	{0x066A,0x04},
	{0x066B,0x25},
	{0x066C,0x00},
	{0x066D,0x12},
	{0x066E,0x00},
	{0x066F,0x80},
	{0x0670,0x00},
	{0x0671,0x0A},
	{0x0672,0x04},
	{0x0673,0x1D},
	{0x0674,0x04},
	{0x0675,0x1D},
	{0x0676,0x00},
	{0x0677,0x7E},
	{0x0678,0x01},
	{0x0679,0x47},
	{0x067A,0x00},
	{0x067B,0x73},
	{0x067C,0x04},
	{0x067D,0x14},
	{0x067E,0x04},
	{0x067F,0x28},
	{0x0680,0x00},
	{0x0681,0x22},
	{0x0682,0x00},
	{0x0683,0xA5},
	{0x0684,0x00},
	{0x0685,0x1E},
	{0x0686,0x04},
	{0x0687,0x1D},
	{0x0688,0x04},
	{0x0689,0x19},
	{0x068A,0x04},
	{0x068B,0x21},
	{0x068C,0x04},
	{0x068D,0x0A},
	{0x068E,0x04},
	{0x068F,0x25},
	{0x0690,0x04},
	{0x0691,0x15},
	{0x0698,0x20},
	{0x0699,0x20},
	{0x069A,0x01},
	{0x069C,0x10},
	{0x069D,0x10},
	{0x069E,0x10},
	{0x069F,0x08},
	{0x0000,0x01},
	{0x0100,0x01},
	{0x0101,0x01},
	{0x0005,0x01},

	{HM2057_TABLE_END, 0x00}
};

enum {
	HM2057_MODE_PREVIEW,
	HM2057_MODE_VIDEO,
	HM2057_MODE_CAPTURE,
	HM2057_MODE_UNKNOWN,
};

static struct hm2057_reg mode_unknown[] = {

	{0x0006,0x03},
	{0x000D,0x11},
	{0x000E,0x11},
	{0x0011,0x02},
	{0x0012,0x1C},
	{0x0013,0x01},
	{0x0070,0x5F},
	{0x0071,0xFF},
	{0x0072,0x55},
	{0x0073,0x50},
	{0x0540,0x00},
	{0x0541,0x9D},
	{0x0542,0x00},
	{0x0543,0xBC},
	{0x0380,0xFF},
	{0x011F,0x80},
	{0x0125,0xFF},
	{0x0126,0x70},
	{0x0131,0xAD},
	{0x0366,0x08},
	{0x0433,0x10},
	{0x0435,0x14},
	{0x05E0,0xA0},
	{0x05E1,0x00},
	{0x05E2,0xA0},
	{0x05E3,0x00},
	{0x05E4,0x04},
	{0x05E5,0x00},
	{0x05E6,0x83},
	{0x05E7,0x02},
	{0x05E8,0x06},
	{0x05E9,0x00},
	{0x05EA,0xE5},
	{0x05EB,0x01},
	{0x0000,0x01},
	{0x0100,0x01},
	{0x0101,0x01},
	
	{HM2057_TABLE_WAIT_MS, 0x80},
	{HM2057_TABLE_END, 0x00}
};

/* Senor full resolution setting: recommand for capture */
static struct hm2057_reg mode_video[] = {
	{0x0006,0x0B},
	{0x000D,0x00},
	{0x000E,0x00},	
	{0x0015,0x02},
	{0x0016,0xA0},
	{0x0012,0x08},
	{0x0013,0x00},
	{0x0070,0x5F},
	{0x0071,0xFF},
	{0x0072,0x99},	
	{0x0540,0x00},
	{0x0541,0xBC},
	{0x0542,0x00},
	{0x0543,0xE1},
	{0x011F,0xFF},
	{0x0125,0xDF},
	{0x0126,0x70},
	{0x0131,0xAC},
	{0x0366,0x20},
	{0x0433,0x40},
	{0x0435,0x50},
	{0x05E4,0x08},
	{0x05E5,0x00},
	{0x05E6,0x07},
	{0x05E7,0x05},
	{0x05E8,0x06},
	{0x05E9,0x00},
	{0x05EA,0xD5},
	{0x05EB,0x02},
	{0x0000,0x01},
	{0x0100,0x01},
	{0x0101,0x01},

	{HM2057_TABLE_WAIT_MS, 0xFF},
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg mode_capture[] = {
	{0x0006,0x03},
	{0x000D,0x00},
	{0x000E,0x00},
	{0x0540,0x00},
	{0x0541,0x9B},
	{0x0542,0x00},
	{0x0543,0xBA},
	{0x011F,0xFF},
	{0x0125,0xDF},
	{0x0126,0x70},
	{0x0131,0xAC},
	{0x0366,0x20},
	{0x0433,0x40},
	{0x0435,0x50},
	{0x05E4,0x0A},
	{0x05E5,0x00},
	{0x05E6,0x49},
	{0x05E7,0x06},
	{0x05E8,0x0A},
	{0x05E9,0x00},
	{0x05EA,0xB9},
	{0x05EB,0x04},
	{0x0000,0x01},
	{0x0100,0x01},
	{0x0101,0x01},

	{HM2057_TABLE_WAIT_MS, 0x80},
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg mode_preview[] = {
	{0x0006,0x03},
	{0x000D,0x11},
	{0x000E,0x11},
	{0x0011,0x02},
	{0x0012,0x1C},
	{0x0013,0x01},
	{0x0070,0x5F},
	{0x0071,0xFF},
	{0x0072,0x55},
	{0x0073,0x50},
	{0x0540,0x00},
	{0x0541,0x9D},
	{0x0542,0x00},
	{0x0543,0xBC},
	{0x0380,0xFF},
	{0x011F,0x80},
	{0x0125,0xDF},
	{0x0126,0x70},
	{0x0131,0xBD},
	{0x0366,0x08},
	{0x0433,0x10},
	{0x0435,0x14},
	{0x05E0,0xA0},
	{0x05E1,0x00},
	{0x05E2,0xA0},
	{0x05E3,0x00},
	{0x05E4,0x05},
	{0x05E5,0x00},
	{0x05E6,0x24},
	{0x05E7,0x03},
	{0x05E8,0x08},
	{0x05E9,0x00},
	{0x05EA,0x5F},
	{0x05EB,0x02},
	{0x0000,0x01},
	{0x0100,0x01},
	{0x0101,0x01},
	
	{HM2057_TABLE_WAIT_MS, 0x80},
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg *mode_table[] = {
	[HM2057_MODE_PREVIEW] = mode_preview,
	[HM2057_MODE_VIDEO] = mode_video,
	[HM2057_MODE_CAPTURE] = mode_capture,
	[HM2057_MODE_UNKNOWN] = mode_unknown,
};	
	
enum {
	HM2057_WB_INVALID = 0,
	HM2057_WB_AUTO,
	HM2057_WB_INCANDESCENT,
	HM2057_WB_DAYLIGHT, 	
	HM2057_WB_UNKNOWN,
	HM2057_WB_FLUORESCENT,
	HM2057_WB_CLOUDY,
};

static struct hm2057_reg wb_auto[] = {
    {0x0380, 0xFF},
    {0x0101, 0xFF},

	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg wb_incandescent[] = {
    {0x0380, 0xFD},
    {0x032D, 0x00},
    {0x032E, 0x01},
    {0x032F, 0x14},
    {0x0330, 0x01},
    {0x0331, 0xD6},
    {0x0332, 0x01},
    {0x0101, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg wb_daylight[] = {
    {0x0380, 0xFD},
    {0x032D, 0x60},
    {0x032E, 0x01},
    {0x032F, 0x00},
    {0x0330, 0x01},
    {0x0331, 0x20},
    {0x0332, 0x01},
    {0x0101, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg wb_fluorescent[] = {
    {0x0380, 0xFD},
    {0x032D, 0x34},
    {0x032E, 0x01},
    {0x032F, 0x00},
    {0x0330, 0x01},
    {0x0331, 0x92},
    {0x0332, 0x01},
    {0x0101, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg wb_cloudy[] = {
    {0x0380, 0xFD},
    {0x032D, 0x70},
    {0x032E, 0x01},
    {0x032F, 0x00},
    {0x0330, 0x01},
    {0x0331, 0x08},
    {0x0332, 0x01},
    {0x0101, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

enum {
	HM2057_YE_INVALID = 0,
	HM2057_YE_PLUS2,
	HM2057_YE_PLUS1,
	HM2057_YE_ZERO,
	HM2057_YE_MINUS1,
	HM2057_YE_MINUS2,
};

static struct hm2057_reg ye_plus2[] = {
	{0x04C0, 0x40},
	{0x038E, 0x68},
	{0x0381, 0x70},
	{0x0382, 0x60},
	{0x0100, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ye_plus1[] = {
	{0x04C0, 0x20},
	{0x038E, 0x58},
	{0x0381, 0x60},
	{0x0382, 0x50},
	{0x0100, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ye_zero[] = {
	{0x04C0, 0x00},
	{0x038E, 0x48},
	{0x0381, 0x50},
	{0x0382, 0x40},
	{0x0100, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ye_minus1[] = {
	{0x04C0, 0xA0},
	{0x038E, 0x38},
	{0x0381, 0x40},
	{0x0382, 0x30},
	{0x0100, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ye_minus2[] = {
	{0x04C0, 0xC0},
	{0x038E, 0x28},
	{0x0381, 0x30},
	{0x0382, 0x20},
	{0x0100, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

enum {
	HM2057_CE_INVALID = 0,
	HM2057_CE_BLUISH,
	HM2057_CE_NEGATIVE,
	HM2057_CE_WANDB,
	HM2057_CE_SEPIA,
	HM2057_CE_NORMAL,
	HM2057_CE_GREEN,
};

static struct hm2057_reg ce_bluish[] = {
	{0x0005, 0x00},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	{0x0488, 0x11},
	{0x0486, 0xB0},
	{0x0487, 0x80},
	{0x0120, 0x37},
	{0x0101, 0xFF},
	{0x0005, 0x01},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	
	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ce_negative[] = {
	{0x0005, 0x00},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	{0x0488, 0x10},
	{0x0486, 0x00},
	{0x0487, 0xFF},
	{0x0120, 0x37},
	{0x0101, 0xFF},
	{0x0005, 0x01},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},

	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ce_wandb[] = {
	{0x0005, 0x00},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	{0x0488, 0x10},
	{0x0486, 0x00},
	{0x0487, 0xFF},
	{0x0120, 0x27},
	{0x0101, 0xFF},
	{0x0005, 0x01},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},

	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ce_sepia[] = {
	{0x0005, 0x00},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	{0x0488, 0x11},
	{0x0486, 0x80},
	{0x0487, 0x80},
	{0x0005, 0x01},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},

	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ce_normal[] = {
	{0x0005, 0x00},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	{0x0488, 0x10},
	{0x0486, 0x00},
	{0x0487, 0xFF},
	{0x0005, 0x01},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},

	{HM2057_TABLE_END, 0x00}
};

static struct hm2057_reg ce_green[] = {
	{0x0005, 0x00},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},
	{0x0488, 0x11},
	{0x0486, 0x60},
	{0x0487, 0x60},
	{0x0120, 0x27},
	{0x0101, 0xFF},
	{0x0005, 0x01},
	{0x0000, 0xFF},
	{0x0100, 0xFF},
	{0x0101, 0xFF},

	{HM2057_TABLE_END, 0x00}
};

/*
// Automatic exposure: Maximum exposure setting (775) 10fps
{0x038F, 0x03},
{0x0390, 0x07},
{0x02E0, 0x02},
{0x0481, 0x08},
{0x04B1, 0x00},
{0x04B4, 0x00},
{0x0000, 0xFF},
{0x0100, 0xFF},
{0x0101, 0xFF},
{HM2057_TABLE_END, 0x00}

// Automatic exposure: Maximum exposure setting (2560) 5fps
{0x038F, 0x0A},
{0x0390, 0x00},
{0x02E0, 0x02},
{0x0481, 0x08},
{0x04B1, 0x00},
{0x04B4, 0x00},
{0x0000, 0xFF},
{0x0100, 0xFF},
{0x0101, 0xFF},
{HM2057_TABLE_END, 0x00}
*/

static int hm2057_read_reg(struct i2c_client *client, u16 addr, u8 *val)
{
	int err;
	struct i2c_msg msg[2];
	unsigned char data[3];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len = 1;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)

		return -EINVAL;

	*val = data[2];

	return 0;
}

static int hm2057_write_reg(struct i2c_client *client, u16 addr, u8 val)
{
	int err;
	struct i2c_msg msg;
	unsigned char data[3];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);
	data[2] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 3;
	msg.buf = data;

	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("hm2057: i2c transfer failed, retrying %x %x\n",
		       addr, val);

		msleep(3);
	} while (retry <= HM2057_MAX_RETRIES);

	return err;
}

static int hm2057_write_table(struct i2c_client *client,
			      const struct hm2057_reg table[],
			      const struct hm2057_reg override_list[],
			      int num_override_regs)
{
	int err;
	const struct hm2057_reg *next;
	int i;
	u16 val;

	for (next = table; next->addr != HM2057_TABLE_END; next++) {
		if (next->addr == HM2057_TABLE_WAIT_MS) {
			msleep(next->val);
			continue;
		}


		val = next->val;

		/* When an override list is passed in, replace the reg */
		/* value to write if the reg is in the list            */
		if (override_list) {
			for (i = 0; i < num_override_regs; i++) {
				if (next->addr == override_list[i].addr) {
					val = override_list[i].val;
					break;
				}
			}
		}

		err = hm2057_write_reg(client, next->addr, val);
		if (err)
			return err;
	}
	return 0;
}

static int hm2057_get_chipid(struct hm2057_info *info)
{
	int err;
	u8 chipid[2] = {0};
	
	info->pdata->power_on();
	tegra_camera_mclk_on_off(1);
	
	err = hm2057_read_reg(info->i2c_client, 0x0001, &chipid[0]);
	if (err < 0)
		goto read_err;
	err = hm2057_read_reg(info->i2c_client, 0x0002, &chipid[1]);
	if (err < 0)
		goto read_err;
		
	pr_info("hm2057: Chip ID %x%x\n", chipid[0], chipid[1]);

	tegra_camera_mclk_on_off(0);
	info->pdata->power_off();

read_err:	
	return err;	
}

static int hm2057_set_mode(struct hm2057_info *info, struct hm2057_mode *mode)
{
	int sensor_mode;
	int err;

	pr_info("%s: xres %u yres %u\n",
		__func__, mode->xres, mode->yres);
		
	if (mode->xres == 640 && mode->yres == 480)
		sensor_mode = HM2057_MODE_PREVIEW;
	else if (mode->xres == 1280 && mode->yres == 720)
		sensor_mode = HM2057_MODE_VIDEO;
	else if (mode->xres == 1600 && mode->yres == 1200)
		sensor_mode = HM2057_MODE_CAPTURE;
	else { 
		pr_err("%s: invalid resolution supplied to set mode %d %d\n",
		       __func__, mode->xres, mode->yres);
		return -EINVAL;
	}	/* HM2057_MODE_UNKNOWN */	

	err = hm2057_write_table(info->i2c_client, mode_table[sensor_mode], NULL, 0);
	if (err)
		return err;
		
	info->mode = sensor_mode;
	return 0;	
}

static long hm2057_ioctl(struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	int err = 0;
	struct hm2057_info *info = file->private_data;
/*	
	pr_info("hm2057 hm2057_ioctl 0x%x\n", cmd);
	print_hex_dump(KERN_DEBUG, "raw data: ", DUMP_PREFIX_NONE,
						16, 1, arg, 16, true);
*/
	switch (cmd) {
	case HM2057_IOCTL_SET_MODE:
	{	
		struct hm2057_mode mode;
		if (copy_from_user(&mode,
				   (const void __user *)arg,
				   sizeof(struct hm2057_mode))) {
			return -EFAULT;
		}

		return hm2057_set_mode(info, &mode);
	}	
	case HM2057_IOCTL_SET_COLOR_EFFECT:
	{
		u8 coloreffect;

		if (copy_from_user(&coloreffect,(const void __user *)arg,
			sizeof(coloreffect))) {
			return -EFAULT;
		}
		
		switch(coloreffect) {
		case HM2057_CE_BLUISH:	
			err = hm2057_write_table(info->i2c_client, ce_bluish, NULL, 0);
			break;		
		case HM2057_CE_NEGATIVE:
			err = hm2057_write_table(info->i2c_client, ce_negative, NULL, 0);
			break;			
		case HM2057_CE_WANDB:
			err = hm2057_write_table(info->i2c_client, ce_wandb, NULL, 0);
			break;			
		case HM2057_CE_SEPIA:
			err = hm2057_write_table(info->i2c_client, ce_sepia, NULL, 0);
			break;			
		case HM2057_CE_NORMAL:
			err = hm2057_write_table(info->i2c_client, ce_normal, NULL, 0);
			break;			
		case HM2057_CE_GREEN:	
			err = hm2057_write_table(info->i2c_client, ce_green, NULL, 0);
			break;			
		default:
			break;
		}
		
		if (err)
			return err;
			
		return 0;
	}		
	case HM2057_IOCTL_SET_WHITE_BALANCE:
	{
		u8 whitebalance;

		if (copy_from_user(&whitebalance,(const void __user *)arg,
			sizeof(whitebalance))) {
			return -EFAULT;
		}

		switch(whitebalance) {
		case HM2057_WB_AUTO:
			err = hm2057_write_table(info->i2c_client, wb_auto, NULL, 0);
			break;
		case HM2057_WB_INCANDESCENT:
			err = hm2057_write_table(info->i2c_client, wb_incandescent, NULL, 0);
			break;
		case HM2057_WB_DAYLIGHT:
			err = hm2057_write_table(info->i2c_client, wb_daylight, NULL, 0);
			break;
		case HM2057_WB_FLUORESCENT:
			err = hm2057_write_table(info->i2c_client, wb_fluorescent, NULL, 0);
			break;
		case HM2057_WB_CLOUDY:
			err = hm2057_write_table(info->i2c_client, wb_cloudy, NULL, 0);
			break;
		case HM2057_WB_UNKNOWN:
		default:
			break;
		}
		
		if (err)
			return err;

		return 0;
	}
	case HM2057_IOCTL_SET_EXPOSURE:
	{
		u8 exposure;

		if (copy_from_user(&exposure,(const void __user *)arg,
			sizeof(exposure))) {
			return -EFAULT;
		}

		switch(exposure) {
		case HM2057_YE_PLUS2:
			err = hm2057_write_table(info->i2c_client, ye_plus2, NULL, 0);
			break;		
		case HM2057_YE_PLUS1:
			err = hm2057_write_table(info->i2c_client, ye_plus1, NULL, 0);
			break;			
		case HM2057_YE_ZERO:
			err = hm2057_write_table(info->i2c_client, ye_zero, NULL, 0);
			break;			
		case HM2057_YE_MINUS1:
			err = hm2057_write_table(info->i2c_client, ye_minus1, NULL, 0);
			break;				
		case HM2057_YE_MINUS2:
			err = hm2057_write_table(info->i2c_client, ye_minus2, NULL, 0);
			break;			
		default:
			break;
		}

		if (err)
			return err;
		
		return 0;
	}
	default:
		return -EINVAL;
	}

	return 0;
}

static int hm2057_open(struct inode *inode, struct file *file)
{
	int err;
	
	file->private_data = info;
	if (info->pdata && info->pdata->power_on)
		info->pdata->power_on();
			
	err = hm2057_write_table(info->i2c_client, hm2057_init_data, NULL, 0);
	if (err)
		return err;

	info->sensor_opened = true;

	return 0;
}

int hm2057_release(struct inode *inode, struct file *file)
{
	if (info->pdata && info->pdata->power_off)
		info->pdata->power_off();
	info->sensor_opened = false;
	file->private_data = NULL;
	return 0;
}

static const struct file_operations hm2057_fileops = {
	.owner = THIS_MODULE,
	.open = hm2057_open,
	.unlocked_ioctl = hm2057_ioctl,
	.release = hm2057_release,
};

static struct miscdevice hm2057_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "hm2057",
	.fops = &hm2057_fileops,
};

static int hm2057_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	int err;
	
	pr_info("hm2057: probing sensor.\n");

	info = kzalloc(sizeof(struct hm2057_info), GFP_KERNEL);
	if (!info) {
		pr_err("hm2057: Unable to allocate memory!\n");
		return -ENOMEM;
	}

	err = misc_register(&hm2057_device);
	if (err) {
		pr_err("hm2057: Unable to register misc device!\n");
		kfree(info);
		return err;
	}

	info->pdata = client->dev.platform_data;
	info->i2c_client = client;

	i2c_set_clientdata(client, info);

	if (info->pdata && info->pdata->init) {
		info->pdata->init();
	} else 
		return -1;

	if (hm2057_get_chipid(info) < 0) {
		pr_err("hm2057: Chip ID is not recognized\n");
		return -1;
	}
	
	return 0;
}

static int hm2057_remove(struct i2c_client *client)
{
	struct hm2057_info *info;
	info = i2c_get_clientdata(client);
	misc_deregister(&hm2057_device);
	kfree(info);
	return 0;
}

static const struct i2c_device_id hm2057_id[] = {
	{ "hm2057", 0 },
	{ },
};

MODULE_DEVICE_TABLE(i2c, hm2057_id);

static struct i2c_driver hm2057_i2c_driver = {
	.driver = {
		.name = "hm2057",
		.owner = THIS_MODULE,
	},
	.probe = hm2057_probe,
	.remove = hm2057_remove,
	.id_table = hm2057_id,
};

static int __init hm2057_init(void)
{
	pr_info("hm2057 sensor driver loading\n");
	return i2c_add_driver(&hm2057_i2c_driver);
}

static void __exit hm2057_exit(void)
{
	i2c_del_driver(&hm2057_i2c_driver);
}

module_init(hm2057_init);
module_exit(hm2057_exit);